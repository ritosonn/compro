#include<cstdio>
/**
 * X = {(u,v)|0<=u,v<=N && ∃a,b>=0, s.t. a^b==u,a+b==v} に対して #X mod p を求める。(1<=N<=1e18)
 * 
 * 1. 条件を満たす(u,v)に対してu<=vが成り立つので、0<=u<=v<=Nと仮定してよい。
 * 
 * 2. Y = {(a,b)|0<=a,b && a+b<=N} に対して全射 f: Y → X; (a,b) ↦ (a^b,a+b) を考える。
 *    このとき、「f(a,b)==f(a',b') ⇔ (a,b)の同じ位置にあるビットをいくつか置き換えると(a',b')になる」を示す。
 * proof) (⇐) a^b, a+bは同じ位置のビットの置き換えで変化しないのでOK。
 *        (⇒) 背理法。a^b==a'^b'なる(a,b),(a',b')で、同じ位置にあるビットの置き換えでは作れないものをとる。
 *            iビット目が置き換えできないとすると、{(aのiビット目,bのiビット目), (a'のiビット目,b'のiビット目)} は
 *            {(0,0),(1,1)} となるしかない（そのほかのパターンならどれも入れ替えができるから）。
 *            すると、a+bとa'+b'の差が1<<(i+1)増加するが、このようなiがいくつあっても（互いに桁が異なるので）
 *            足して0になることはない。これはa+b==a'+b'に反する。//
 *  
 * 3. 2.より、各桁については(0,0),(0,1),(1,1)の3通りだけ考えればよい。
 *  
 * 4. #(Y/{この同値類}) を桁DPで求める。
 *    dp[d][s] := 「a+bとN-s*(1<<d)が上から見てdビット目まで等しいような場合の数」とおくと、
 *    求めるものは sum_s(dp[0][s])である。
 *    dp[infty][0] = 1 を初期値とする。
 *    dp[d+1][s] = 「a+bとN-s*(1<<(d+1)) == N-2*s*(1<<d)がd+1ビット目まで等しい場合の数」なので、
 *    Nのdビット目をN_dと書くと、
 *    - a,bのdビット目の和が0のとき dp[d][2*s+N_d] += dp[d+1][s]
 *    - a,bのdビット目の和が1のとき dp[d][2*s+N_d-1] += dp[d+1][s]
 *    - a,bのdビット目の和が2のとき dp[d][2*s+N_d-2] += dp[d+1][s]
 *    s>=2のとき2*s+N_d-2>=4+0-2>=2なので、s∈{0,1,2}として、dの大きい順に計算していけばよい。
 */
using ll = long long;
constexpr ll p=1e9+7;
int main(){
    ll n, dp[64][3]={0};
    scanf("%lld",&n);
    dp[63][0]=1;
    for(int d=62;d>=0;d--){
        int n_d=(n>>d)&1;
        for(int s=0;s<=2;s++){
            for(int k=0;k<=2;k++){
                int s2=2*s+n_d-k;
                if(s2>2)s2=2;
                if(s2>=0)dp[d][s2]+=dp[d+1][s];
                dp[d][s2]%=p;
            }
        }
    }
    printf("%lld\n",(dp[0][0]+dp[0][1]+dp[0][2])%p);
    return 0;
}