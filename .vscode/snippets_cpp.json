{
	"modint": {
		"prefix": "modint",
		"body": [
			"template<typename ll_t,ll_t mod>",
			"class basic_modint{",
			"public:",
			"    ll_t x_;",
			"    basic_modint(ll_t x=0):x_((x%mod+mod)%mod){}",
			"    basic_modint& operator+=(const basic_modint a)       { if((x_+=     a.x_)>=mod)x_-=mod; return *this; }",
			"    basic_modint& operator-=(const basic_modint a)       { if((x_+= mod-a.x_)>=mod)x_-=mod; return *this; }",
			"    basic_modint& operator*=(const basic_modint a)       { (x_*=a.x_)%=mod; return *this; }",
			"    basic_modint  operator+ (const basic_modint a) const { basic_modint res(*this); return res+=a; }",
			"    basic_modint  operator- (const basic_modint a) const { basic_modint res(*this); return res-=a; }",
			"    basic_modint  operator* (const basic_modint a) const { basic_modint res(*this); return res*=a; }",
			"    basic_modint  pow(ll_t t) const { if(t==0)return 1; basic_modint a = pow(t>>1); a*=a; if(t%2==1)a*=(*this); return a; }",
			"    basic_modint  inv() const { return pow(mod-2); }",
			"    basic_modint& operator/=(const basic_modint a)       { return (*this) *= a.inv(); }",
			"    basic_modint  operator/ (const basic_modint a) const { basic_modint res(*this); return res/=a; }",
			"    friend istream& operator>>(istream& ist, basic_modint& a) { ist>>a.x_; return ist; }",
			"    friend ostream& operator<<(ostream& ost, basic_modint& a) { ost<<a.x_; return ost; }",
			"    bool operator==(const basic_modint a){return x_==a.x_; }",
			"    bool operator!=(const basic_modint a){return x_!=a.x_; }",
			"};",
			"using mint = basic_modint<ll,ll(1e9+7)>;"
		],
		"description": "auto mod int, using template"
	},
	"factorize": {
		"prefix": "factorize",
		"body": [
			"template<typename ll_t>",
			"vector<pair<ll_t,ll_t>> factorize(ll_t x){",
			"    vector<pair<ll_t,ll_t>> ret; ll_t x_tmp=x, cnt;",
			"    if(x_tmp%2==0) { cnt=0; while(x_tmp%2==0) {x_tmp/=2; ++cnt;} ret.push_back({2,cnt});}",
			"    for(ll_t p=3;x_tmp>1&&p*p<=x;p+=2) if(x_tmp%p==0) { cnt=0; while(x_tmp%p==0) {x_tmp/=p; ++cnt;} ret.push_back({p,cnt});}",
			"    if(x_tmp>1)ret.push_back({x_tmp,1});",
			"    return ret;",
			"}"
		],
		"description": "list of primes and factors"
	},
	"divisors":{
		"prefix": "divisors",
		"body": [
			"template<typename ll_t>",
			"vector<ll_t> divisors(ll_t x){",
			"    auto factors=factorize(x); vector<ll_t> ret; ret.push_back(1);",
			"    for(auto &p_s:factors){",
			"        ll_t p=p_s.first, s=p_s.second; vector<ll_t> tmp;",
			"        for(auto &r:ret){ ll_t d=r; for(ll_t i=0;i<=s;++i){ tmp.push_back(d); d*=p; } }",
			"        ret=tmp;}",
			"    sort(ret.begin(),ret.end()); return ret;",
			"}"
		],
		"description": "list of divisors"
	},
	"segmenttree":{
		"prefix": "segmenttree",
		"body": [
			"template<typename M,M f(M,M),M M1>",
			"class SegmentTreeBase{",
			"    using F=function<M(M,M)>; size_t sz; vector<M> seg;",
			"public:",
			"    SegmentTreeBase(size_t n){ sz=1; while(sz<n)sz<<=1; seg.assign(2*sz,M1); }",
			"    const M& operator[](size_t k) const { return seg[k+sz]; }",
			"    M& operator[](size_t k){ return seg[k+sz]; }",
			"    void build(){ for(size_t k=sz-1;k>0;--k)seg[k]=f(seg[2*k], seg[2*k+1]); }",
			"    void update(size_t k, const M &x) { k+=sz; seg[k]=x; while(k>>=1)seg[k]=f(seg[2*k],seg[2*k+1]); }",
			"    M query(size_t a, size_t b) { M L=M1,R=M1; for(a+=sz,b+=sz; a<b; a>>=1,b>>=1){ if(a&1)L=f(L,seg[a++]); if(b&1)R=f(seg[--b],R); } return f(L,R); }",
			"};",
			"ll func_max(ll a,ll b){ return std::max(a,b); }",
			"using segmax = SegmentTreeBase<ll,func_max,numeric_limits<ll>::min()>;",
			"ll func_min(ll a,ll b){ return std::min(a,b); }",
			"using segmin = SegmentTreeBase<ll,func_min,numeric_limits<ll>::max()>;",
			"ll func_plus(ll a,ll b){ return a+b; }",
			"using segplus = SegmentTreeBase<ll,func_plus,0LL>;"
		],
		"description": "O(log n) sum of [a,b)"
	},
	"compression":{
		"prefix": "compression",
		"body": [
			"template<typename T>",
			"    vector<int> compression(const vector<T> &v){",
			"    vector<T> vals; for(auto &vi:v)vals.push_back(vi); sort(vals.begin(),vals.end()); vals.erase(unique(vals.begin(),vals.end()),vals.end());",
			"    vector<int> ret; rep(i,(int)v.size())ret.push_back((int)(lower_bound(vals.begin(),vals.end(),v[i])-vals.begin())); return ret;",
			"}"
		],
		"description": "compress from vector to [0,vector.size)"
	},
	"inversion-number":{
		"prefix": "inversion number",
		"body": [
			"ll inversion_number(const vector<int> &v_zip){",
			"    ll ret = 0; segplus seg(v_zip.size());",
			"    for(auto itr=v_zip.begin();itr!=v_zip.end();++itr){ auto t=seg.query(0,*itr); ret += (int)(itr-v_zip.begin())-t; seg.update(*itr,1); }",
			"    return ret;",
			"}"
		],
		"description": "O(nlogn) inversion number of compressed vector, using segment tree"
	},
	"gcd":{
		"prefix": "gcd",
		"body": "template<typename T> T gcd_(T a,T b){ return (a%b)?gcd_(b,a%b):b; }",
		"description": "greatest common divisor"
	},
	"unionfind":{
		"prefix": "unionfind",
		"body": [
			"class UnionFind{",
			"    int l_, cnt_, *parent_, *rank_;",
			"public:",
			"    UnionFind(int l):l_(l),cnt_(l){ parent_=new int[l]; rep(i,l)parent_[i]=-1; rank_=new int[l]; rep(i,l)rank_[i]=0; }",
			"    ~UnionFind(){ delete[] parent_; delete[] rank_; }",
			"    int root(int x){ return (parent_[x]<0)?x:(parent_[x]=root(parent_[x])); }",
			"    void unite(int x,int y){ int rx=root(x),ry=root(y); if(rx!=ry){ --cnt_;",
			"        if(rank_[rx]>rank_[ry]){ parent_[rx]+=parent_[ry]; parent_[ry]=rx; }",
			"        else{ if(rank_[rx]==rank_[ry])++rank_[ry]; parent_[ry]+=parent_[rx]; parent_[rx]=ry; }}}",
			"    bool isSameTree(int x,int y){ return root(x)==root(y); }",
			"    int sizeOf(int x){ return -parent_[root(x)]; }",
			"    int count_component(){ return cnt_; }",
			"};"
		],
		"description": "O(alpha(n)) union-find tree"
	},
	"graph":{
		"prefix": "graph",
		"body": "template<typename weight_t> using graph = vector<vector<pair<int,weight_t>>>;",
		"description": "definitions of graph"
	},
	"dijkstra":{
		"prefix": "dijkstra",
		"body": [
			"template<typename weight_t> vector<weight_t> dijkstra(const graph<weight_t> &g,const int e){",
			"    using node=pair<int,weight_t>; auto cmp=[](node &a,node &b)->bool {return (a.second>b.second);};",
			"    priority_queue<node,vector<node>,decltype(cmp)> pq(cmp);",
			"    vector<weight_t> w(g.size(),numeric_limits<weight_t>::max());",
			"    vector<bool> done(g.size(),false); pq.push({e,0}); w[e]=0;",
			"    while(!pq.empty()){ auto u=pq.top(); pq.pop(); if(done[u.first])continue; done[u.first]=true;",
			"        for(auto &v:g[u.first]) if(w[u.first]+v.second<w[v.first]){",
			"            w[v.first]=w[u.first]+v.second; pq.push({v.first,w[v.first]}); }}",
			"    return w;",
			"}"
		],
		"description": "O(E+VlogV) shortest path length of non-negative edges (dijkstra's algorithm) "
	},
	"dag":{
		"prefix": ["dag","topologicalsort"],
		"body": [
			"template<typename weight_t> bool visit_dag(int n, const graph<weight_t> &g, vector<int> &mark, vector<int> &l){",
			"if(mark[n]==1)return false; else if(mark[n]==0){ mark[n]=1; for(auto &m:g[n])if(!visit_dag(m.first,g,mark,l))return false; mark[n]=2; l.push_back(n); } return true; }",
			"template<typename weight_t> vector<int> topological_sort(const graph<weight_t> &g){",
			"    vector<int> mark(g.size(),0),l; loop(i,g.size())if(mark[i]==0&&!visit_dag(i,g,mark,l))return {}; reverse(l.begin(),l.end()); return l; }",
			"template<typename weight_t> bool is_dag(const graph<weight_t> &g){ return !topological_sort(g).empty(); }",
			"template<typename weight_t> graph<weight_t> inverse(const graph<weight_t> &g){",
			"    graph<weight_t> h(g.size()); loop(i,g.size())loop(j,g[i].size())h[g[i][j]].push_back(i); return h; }",
			"template<typename weight_t> int longest_path_dag(const graph<weight_t> &g){",
			"    auto l=graph<weight_t>(g); if(l.empty())return -1;",
			"    auto h=inverse(g); vector<int> dist(g.size(),1);",
			"    loop(i,g.size())loop(j,h[l[i]].size())dist[l[i]]=max(dist[l[i]],1+dist[h[l[i]][j]]);",
			"    return *max_element(dist.begin(),dist.end()); }"
		],
		"description": "O(E+V) topological sort using DFS, and decide if a graph is directed acyclic graph."
	}
}