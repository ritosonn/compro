{
	"modint": {
		"prefix": "modint",
		"body": [
			"template<typename ll_t,ll_t mod>",
			"class basic_modint{",
			"public:",
			"    ll_t x_;",
			"    basic_modint(ll_t x=0):x_((x%mod+mod)%mod){}",
			"    basic_modint& operator+=(const basic_modint a)       { if((x_+=     a.x_)>=mod)x_-=mod; return *this; }",
			"    basic_modint& operator-=(const basic_modint a)       { if((x_+= mod-a.x_)>=mod)x_-=mod; return *this; }",
			"    basic_modint  operator+ (const basic_modint a) const { basic_modint res(*this); return res+=a; }",
			"    basic_modint  operator- (const basic_modint a) const { basic_modint res(*this); return res-=a; }",
			"    basic_modint  operator* (const basic_modint a) const { basic_modint res(*this); return res*=a; }",
			"    basic_modint  pow(ll_t t) const { if(t==0)return 1; basic_modint a = pow(t>>1); a*=a; if(t%2==1)a*=(*this); return a; }",
			"    basic_modint  inv() const { return pow(mod-2); }",
			"    basic_modint& operator/=(const basic_modint a)       { return (*this) *= a.inv(); }",
			"    basic_modint  operator/ (const basic_modint a) const { basic_modint res(*this); return res/=a; }",
			"    friend istream& operator>>(istream& ist, basic_modint& a) { ist>>a.x_; return ist; }",
			"    friend ostream& operator<<(ostream& ost, basic_modint& a) { ost<<a.x_; return ost; }",
			"};",
			"using mint = basic_modint<ll,ll(1e9+7)>;"
		],
		"description": "auto mod int, using template"
	},
	"factorize": {
		"prefix": "factorize",
		"body": [
			"template<typename ll_t>",
			"vector<pair<ll_t,ll_t>> factorize(ll_t x){",
			"    vector<pair<ll_t,ll_t>> ret; ll_t x_tmp=x, cnt;",
			"    if(x_tmp%2==0) { cnt=0; while(x_tmp%2==0) {x_tmp/=2; ++cnt;} ret.push_back({2,cnt});}",
			"    for(ll_t p=3;x_tmp>1&&p*p<=x;p+=2) if(x_tmp%p==0) { cnt=0; while(x_tmp%p==0) {x_tmp/=p; ++cnt;} ret.push_back({p,cnt});}",
			"    if(x_tmp>1)ret.push_back({x_tmp,1});",
			"    return ret;",
			"}"
		],
		"description": "list of primes and factors"
	},
	"divisors":{
		"prefix": "divisors",
		"body": [
			"template<typename ll_t>",
			"vector<ll_t> divisors(ll_t x){",
			"    auto factors=factorize(x); vector<ll_t> ret; ret.push_back(1);",
			"    for(auto &p_s:factors){",
			"        ll_t p=p_s.first, s=p_s.second; vector<ll_t> tmp;",
			"        for(auto &r:ret){ ll_t d=r; for(ll_t i=0;i<=s;++i){ tmp.push_back(d); d*=p; } }",
			"        ret=tmp;}",
			"    sort(ret.begin(),ret.end()); return ret;",
			"}"
		],
		"description": "list of divisors"
	},
	"segmenttree":{
		"prefix": "segmenttree",
		"body": [
			"template<typename M,M f(M,M),M M1>",
			"class SegmentTreeBase{",
			"    using F=function<M(M,M)>; size_t sz; vector<M> seg;",
			"public:",
			"    SegmentTreeBase(size_t n){ sz=1; while(sz<n)sz<<=1; seg.assign(2*sz,M1); }",
			"    const M& operator[](size_t k) const { return seg[k+sz]; }",
			"    M& operator[](size_t k){ return seg[k+sz]; }",
			"    void build(){ for(size_t k=sz-1;k>0;--k)seg[k]=f(seg[2*k], seg[2*k+1]); }",
			"    void update(size_t k, const M &x) { k+=sz; seg[k]=x; while(k>>=1)seg[k]=f(seg[2*k],seg[2*k+1]); }",
			"    M query(size_t a, size_t b) { M L=M1,R=M1; for(a+=sz,b+=sz; a<b; a>>=1,b>>=1){ if(a&1)L=f(L,seg[a++]); if(b&1)R=f(seg[--b],R); } return f(L,R); }",
			"};",
			"ll func_max(ll a,ll b){ return std::max(a,b); }",
			"using segmax = SegmentTreeBase<ll,func_max,numeric_limits<ll>::min()>;",
			"ll func_min(ll a,ll b){ return std::min(a,b); }",
			"using segmin = SegmentTreeBase<ll,func_min,numeric_limits<ll>::max()>;",
			"ll func_plus(ll a,ll b){ return a+b; }",
			"using segplus = SegmentTreeBase<ll,func_plus,0LL>;",
		]
	}
}